# Ubiquitongue - Development Roadmap & Issues

This document outlines the development plan for Ubiquitongue, broken down into phases and actionable issues.

---
## Phase 1: Core Data Structure & Local Write Workflow Setup
*(Epic: Data Backend Foundation)*

### `#1` Task: Define Drizzle ORM Schemas for Core Entities
*   **Description:** Implement Drizzle ORM schemas in `src/db/schema.ts` for Papers, Semantics, Syntaxes, and Usages. Finalize decisions on handling array/struct data types (e.g., JSON strings or investigating native DuckDB type mapping via the Drizzle driver).
*   **Acceptance Criteria:** TypeScript schema files exist and are type-correct.

---
### `#2` Task: Setup Persistent DuckDB & Initial Migrations
*   **Description:** Use `drizzle-kit` to generate initial SQL migration files from the Drizzle schemas. Apply these migrations to create the `local_master_data.duckdb` file. Ensure `local_master_data.duckdb` is correctly added to `.gitignore`.
*   **Acceptance Criteria:** `local_master_data.duckdb` can be created and schematized. `.gitignore` is updated. SQL migration files are versioned.

---
### `#3` Task: Develop "Write" GraphQL Server (Pothos + Drizzle)
*   **Description:** Set up a Pothos GraphQL server. Implement basic GraphQL types corresponding to Drizzle schemas. Create initial CUD (Create, Update, Delete) mutations for core entities. Resolvers for these mutations will use Drizzle ORM to write data to `local_master_data.duckdb`. Implement basic input validation in resolvers.
*   **Acceptance Criteria:** Local GraphQL server can be started. Mutations for creating core entities are functional.

---
### `#4` Task: Implement Initial Data Seeding/Testing for "Write" Server
*   **Description:** Use a GraphQL IDE (e.g., Insomnia, Postman) or simple CLI scripts to send GraphQL mutations to the "Write" server. Manually add 2-3 examples for each core entity (Semantics, Syntaxes, Papers) and link them with Usages. Verify data is correctly saved in `local_master_data.duckdb`.
*   **Acceptance Criteria:** Sample data is successfully added and retrievable from DuckDB via SQL.

---
### `#5` Task: Develop Export Script (DuckDB to JSON SSOT)
*   **Description:** Create a Node.js script (e.g., `scripts/duckdb-to-json.js`) that connects to `local_master_data.duckdb`. Implement logic to read all data from each table and generate/update corresponding JSON files in the `data/` directory structure (one file per record). Crucially, handle the deletion of JSON files if their records no longer exist in DuckDB.
*   **Acceptance Criteria:** Script correctly exports data to JSON files. Script handles creation, updates, and deletions of JSON files.

---
## Phase 2: Astro Setup & Build-Time "Read" Workflow
*(Epic: Static Site Generation with Data)*

### `#6` Task: Initialize Astro Project & SolidJS Integration
*   **Description:** Set up a new Astro project using `npm create astro@latest`. Add the SolidJS integration (`npx astro add solid-js`). Establish a basic project structure (`src/pages`, `src/components`, `src/layouts`).
*   **Acceptance Criteria:** Astro dev server runs. A basic SolidJS component can be rendered within an Astro page.

---
### `#7` Task: Develop Build-Time "Read" GraphQL Server
*   **Description:** Create a Pothos GraphQL server instance (or a distinct mode for the main GQL server script). This server will:
    1.  Read all JSON SSOT files from the `data/` directory.
    2.  Parse JSON data.
    3.  Create an in-memory DuckDB instance.
    4.  Apply the canonical SQL schemas (from versioned `.sql` files generated by `drizzle-kit`) to this in-memory DB.
    5.  Load the parsed JSON data into the in-memory DuckDB tables.
    6.  Define GraphQL queries (e.g., `allSemantics`, `getSyntaxById`).
    7.  Resolvers for these queries use Drizzle ORM to fetch data from the in-memory DuckDB.
*   **Acceptance Criteria:** "Read" GQL server starts and can serve data queried from the in-memory DB populated by JSON files.

---
### `#8` Task: Create Basic Astro Pages to Consume "Read" GQL Data
*   **Description:** Implement simple Astro pages (e.g., `src/pages/semantics.astro`, `src/pages/syntaxes.astro`). In the page frontmatter, use `graphql-request` (or `fetch`) to query the "Read" GraphQL server for collections of data (e.g., all semantics). Display the fetched data on these pages.
*   **Acceptance Criteria:** Data from JSON SSOT is visible on Astro pages during development and in the built site.

---
### `#9` Task: Orchestrate Build Scripts (`package.json`)
*   **Description:** Configure npm scripts in `package.json` to correctly sequence the build process:
    1.  (Locally/Optionally) Run `scripts/duckdb-to-json.js` if `local_master_data.duckdb` has been updated.
    2.  Start the "Read" GraphQL server.
    3.  Run `astro build`.
    4.  Ensure the "Read" GQL server is ready before Astro attempts to fetch data (e.g., using `concurrently` with readiness checks or a wait script).
*   **Acceptance Criteria:** `npm run build` successfully generates the static site using data from the "Read" GQL server.

---
## Phase 3: Core UI - Editor & Display
*(Epic: User Interface)*

### `#10` Task: Integrate `typst.ts` for Math Preview
*   **Description:** Install and configure `typst.ts`. Create a basic SolidJS component that accepts a Typst string as a prop and uses `typst.ts` to render a preview of the math notation.
*   **Acceptance Criteria:** A Typst string can be rendered as a visual preview in a SolidJS component.

---
### `#11` Task: Develop SolidJS Display Components for Entities
*   **Description:** Create reusable SolidJS components for displaying individual Semantics (name, description, tags), Syntaxes (Typst string with preview, LaTeX string), Papers (title, authors, year), and Usages (linking the three, context notes).
*   **Acceptance Criteria:** Components correctly render data passed via props.

---
### `#12` Task: Implement List and Detail Pages in Astro
*   **Description:** Create dynamic list pages in Astro (e.g., `/syntaxes` listing all syntaxes) and detail pages (e.g., `/semantics/[id].astro` displaying full details for a single semantic). These pages will fetch data via the "Read" GQL server and use the SolidJS display components.
*   **Acceptance Criteria:** Users can navigate to list and detail views for all core entities.

---
## Phase 4: Search Implementation
*(Epic: Search Functionality)*

### `#13` Task: Implement Client-Side Search Index Generation
*   **Description:** Create a Node.js script (part of the build process, after JSON SSOT is ready) that:
    1.  Reads the relevant JSON data.
    2.  Builds a FlexSearch index. Index `typstStringCanonical` for exact matching, and other fields like `semanticName`, `description` for fuzzy/text matching.
    3.  Saves the serialized FlexSearch index to `public/search-index.json`.
*   **Acceptance Criteria:** `search-index.json` is generated during the build.

---
### `#14` Task: Develop Search UI (SolidJS Island with FlexSearch)
*   **Description:** Create a SolidJS component for the search input and results display. On mount, it fetches `search-index.json` and loads it into a FlexSearch instance. As the user types, it queries FlexSearch and displays results. Initial version can focus on keyword matching on text fields and exact matching on a (yet to be fully defined) canonical syntax string.
*   **Acceptance Criteria:** Basic client-side search functionality is available on the site.

---
## Phase 5: "Smart Input Parser" for Search
*(Epic: Advanced Search UX - Iterative Development)*

### `#15` Feature: Implement Lexer for Search Input (`moo`)
*   **Description:** Define tokens using `moo` for identifiers, numbers, known mathematical symbols, and keywords relevant to notation search (e.g., "union", "sum", "for", "where").
*   **Acceptance Criteria:** User input can be tokenized into a stream of recognized units.

---
### `#16` Feature: Develop Initial Parsing Rules for Common Notation Structures
*   **Description:** Implement logic (either custom JavaScript functions operating on the token stream, or a simple grammar for Peggy/Nearley.js) to recognize a few common user input patterns (e.g., infix binary operators, simple function call syntax like `f(a,b)`). Convert these patterns into your defined `typstStringCanonical` forms.
*   **Acceptance Criteria:** A small set of common input patterns are correctly parsed into canonical query strings.

---
### `#17` Task: Integrate Smart Parser Output with FlexSearch Querying
*   **Description:** Modify the search UI (from #14). The output from the smart input parser (canonical query string(s)) will now be used to perform exact match queries against the `typstStringCanonical` field in FlexSearch. Textual keywords from the input can still be used for broader searches on other fields.
*   **Acceptance Criteria:** Search results improve for structural queries based on parsed input.

---
### `#18` Chore: Iteratively Enhance Parsing Rules & Tokenization
*   **Description:** (Ongoing Task) Based on testing and desired coverage, add more parsing rules, refine token definitions, and improve the robustness of the smart input parser. This can be broken into smaller, specific issues for different notation patterns.
*   **Acceptance Criteria:** Parser handles an increasing range of user inputs accurately.

---
## Phase 6: Local Admin UI for Writes
*(Epic: Data Authoring Tools - Optional/Later Phase)*

### `#19` Feature: Develop Local Admin UI for Data Entry/Management
*   **Description:** (If deemed necessary over CLI/GraphQL IDE) Create a simple local web application (e.g., using Astro/SolidJS, or a separate simple stack) that provides a user interface for creating, updating, and deleting data. This UI will use Relay (if React-based) or `graphql-request` (if SolidJS-based) to interact with the "Write" GraphQL server.
*   **Acceptance Criteria:** Data can be managed via a local web interface.

---
## General / Cross-Cutting Concerns

### `#20` Chore: Setup TypeScript for Entire Project
*   **Description:** Configure TypeScript, add necessary `@types/*` packages, and enforce strong typing across Node.js scripts, Astro components, and SolidJS components.
*   **Acceptance Criteria:** Project uses TypeScript effectively with minimal `any` types.

---
### `#21` Chore: Implement Basic Styling
*   **Description:** Set up basic global styles and layout. If using Tailwind CSS, configure it. Style core components for readability.
*   **Acceptance Criteria:** The website has a clean, usable, and consistent appearance.

---
### `#22` Chore: Configure GitHub Actions for CI/CD
*   **Description:** Create GitHub Actions workflows to:
    1.  Lint and test code on pushes/PRs.
    2.  Build the Astro site (orchestrating the "Read" GQL server and `astro build`).
    3.  Deploy the built static site to GitHub Pages on merges to the main branch.
*   **Acceptance Criteria:** Automated checks, builds, and deployments are functional.

---
### `#23` Docs: Create Initial Project README and Contribution Guidelines
*   **Description:** Write a comprehensive `README.md` for the project, explaining its purpose, setup, and how to run it locally. Draft initial `CONTRIBUTING.md` guidelines.
*   **Acceptance Criteria:** Core project documentation is available.

---
### `#24` Docs: Document Data Schemas and Workflow
*   **Description:** Formalize the Drizzle schemas, JSON SSOT structure, and the overall data workflow (Write -> Export -> Build -> Read) in project documentation. This conversation serves as a strong basis.
*   **Acceptance Criteria:** Data architecture and flow are clearly documented for maintainers.
